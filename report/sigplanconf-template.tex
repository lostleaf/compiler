%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------

\documentclass[nocopyrightspace]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{listings}
\usepackage{mips}
\begin{document}

\conferenceinfo{WXYZ '05}{date, City.}
\copyrightyear{2005}
\copyrightdata{[to be supplied]}

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Report for Compiler Course Project}
%\subtitle{Subtitle Text, if any}

\authorinfo{Qinglin Li}
           {Shanghai Jiaotong University}
           {lostleaf@icloud.com}

\maketitle

\begin{abstract}
This report describes the compiler course project. The design of Abstract syntax tree and immediate representative along with some optimization are included in this report.
\end{abstract}

\category{D.3.4}{Programming Languages}{compiler}


\keywords
Compiler, Abstract Syntax Tree, Immediate Representative, Code Optimization, Register Allocation, Constant Folding

\section{Introduction}
This project aims at building a compiler for a subset of C language. It removed float numbers, some confusing grammars and most library functions in C language. And, of course, the compiler translate C code to MIPS code with ANTLR4 parser generate tool.

\section{Abstract Syntax Tree}
The Abstract Syntax Tree(AST for short) is generated while parsing and the whole process is contained in \textit{C.g4} file under \textit{parser} directory. \\
The AST is similar with Parsing Tree, but removes useless information. Every node in Parsing Tree is corresponded to a node in AST.\\
And since addition, multiplication, and other binary operator expressions are similar, a generic type is used here. And it brings much benefit when generate Immediate Representative.\\
The inheritance of AST is shown below:\\
\begin{itemize}
\item Node
\begin{itemize}
	\item Program
	\item Declaration
	\item $\cdots$
	\item Stmt(Correspond to Statement)
	\begin{itemize}
		\item CompStmt(Correspond to Compound-Statement)
		\item $\cdots$
	\end{itemize}
	\item Expression
	\begin{itemize}
		\item AssExpr(Correspond to Assignment-Statement)
		\item BinExpr$<\text{ExprType}>$(generic type)
		\begin{itemize}
			\item AddExpr:BinExpr$<\text{MulExpr}>$
			\item MulExpr:BinExpr$<\text{CastExpr}>$
			\item $\cdots$
		\end{itemize}
	\end{itemize}
\end{itemize}
\end{itemize}


\section{Semantic Checking}
The semantic checking producure is called after AST generating. Semantic checking mainly check the following items:
\begin{enumerate}
\item Type
\item Left value
\item Declaration and use before declaraed
\item Other items including breaks, returns, etc.
\end{enumerate}

\subsection{Type}
	Types all have upcase class names in case of mixing up with Java type names. \\
	The inheritance:
	\begin{itemize}
		\item TYPE
		\begin{itemize}
			\item CHAR
			\item FUNCTION
			\item INT
			\item VOID
			\item STRING
			\item NAME
			\item POINTER
			\begin{itemize}
				\item ARRAY
			\end{itemize}
			\item RECORD
			\begin{itemize}
				\item UNION
				\item STRUCT
			\end{itemize}
		\end{itemize}
	\end{itemize}
	\textbf{CHAR},\textbf{ INT}, and \textbf{VOID} are singleton classes.\\
	Type checking mainly happened in expressions and some statements.\\
	In expressions, if the oprands and operators doesn't match, a error would be reported. For instance, if a structure is multiplied by an integer, a ``type not match'' error would be reported.\\
	And some statements require special types. For instance, the condition of \textbf{if} or \textbf{while} statements must be integer.

\subsection{Left Value}
	Most left values checking happens in assignments. And some operator such as ``\&''(get address) and ``++''(self increment)\\

\subsection{Declaration}
	The check about declaration and use before declarated is based on symbol table. If a variable cannot be found in the symbol table while used, a ``variable not declaraded'' error would be reported. The uniqueness would also be checked.

\subsection{Returns and Breaks}
	Returns and breaks are checked by some counters.

\subsection{Other items}
	The details not metioned can be found in \textit{Semantic.java} under \textit{semantic} directory

\section{Immediate Representative(IR)}
\subsection{Temp}
\begin{itemize}
\item Addr: an interface all temps need to inplement
\begin{itemize}
	\item Temp: regiseters
	\item Reference: correspond to memory space to support pointers.
	\item Label: labels in MIPS
	\item IntConstant: integers
	\item AddrList: to initialize structures or arrays
\end{itemize}
\end{itemize}
\subsection{Quad}
\begin{itemize}
\item Binop: binary expressions
\item Branch: branch with condition
\item Call: function call
\item Enter: enter a function, save registers
\item Goto: branch with no condition
\item IfFalse: bnez
\item IfTrue: beqz
\item LabelQuad: label, packaging of Label in temps
\item Leave: leave a function, load registers
\item Move: assignment, \textbf{move} in MIPS
\item Return: assign the register for returen value
\item Unaryop: unary operator expressions including \textbf{-a}, \textbf{\textasciitilde a} and \textbf{!a}
\end{itemize}

\section{Code Optimization}
\subsection{Combine Assigntment and IfTrue/IfFalse}
Such a sequence of instructions always appear:
\lstset{language=[mips]Assembler}
\begin{lstlisting}
    slt $t3, $t1, $t2
    bnez $t3, LABEL
\end{lstlisting}
It can be combined:
\begin{lstlisting}
    bge $t1, $t2, LABEL
\end{lstlisting}
So, if the result of a comparison expression like \textbf{slt}(\textsl{Binop with $<$})  is used by a following  \textbf{beqz}(\textsl{IfTrue}) or \textbf{bnez}(\textsl{IfFalse}), the two codes can be combine to one \textsl{Branch}---- \textbf{bge}(\textsl{Branch with `greater or equal'}) in this case.

\subsection{Constant Folding}
Constant folding is an easy but useful optimization. The sequence shown below can be calculated while compiling:
\begin{lstlisting}
li $t1, 1
li $t2, 2
add $t3, $t1, $t2
li $t4, 3
mul $t5, $t3, $t4
\end{lstlisting}
This is MIPS code sequence for
$$t5 = (1+2)*3$$
If \textbf{t5} is replaced with the constant 9, both registers and instructions are reduced.\\
This happens while generating IR, if a \textsl{Binop} has both constant operands, the target would be replaced with a constant of the calculated result.\\
Constant Folding reduced about 170,000 instructions for queens testcase.

\subsection{Register Allocation}
Regiseter Allocation is the most powerful optimimation, and the linear scan algorithm is used here.

\section{Other work}
\subsection{Variable-length array}
Since the length of an array can either be an constant or an temp(register). \\
If the length of the array is an constant, the space would be directly allocate in the stack, else the \textbf{malloc} function would be called.
\subsection{Translate wikipedia}

\appendix

\section{Full inheritance of AST}
\begin{itemize}
	\item Node
	\item Program
	\item InitDeclarator
	\item PlainDeclarator
	\item Parameters
	\item Initializer
	\item InitDeclarators
	\item Declaration
	\item Arguments
	\item FunctionDefinition
	\item Declarators
	\item TypeName
	\item PlainDeclaration

	\item Stmt
	\begin{itemize}
		\item SelStmt
		\item ExprStmt
		\item CompStmt
		\item IterStmt
		\begin{itemize}
			\item ForStmt
			\item WhileStmt
		\end{itemize}
		\item JumpStmt
		\begin{itemize}
			\item ReturnStmt
			\item BreakStmt
			\item ContinueStmt
		\end{itemize}
	\end{itemize}


	\item Expression
	\begin{itemize}
		\item Expr
		\item AssExpr
		\item PriExpr

		\item BinExpr
		\begin{itemize}
			\item ShiftExpr
			\item AddExpr
			\item AndExpr
			\item EquExpr
			\item LogOrExpr
			\item InOrExpr
			\item RelExpr
			\item LogAndExpr
			\item MulExpr
			\item ExOrExpr
		\end{itemize}

		\item Constant
		\begin{itemize}
			\item CharConst
			\item IntConst
		\end{itemize}

		\item Postfix
		\begin{itemize}
			\item SelfDecPostfix
			\item ArrPostfix
			\item PtrAttrPostfix
			\item FunPostfix
			\item ValAttrPostfix
			\item SelfIncPostfix
		\end{itemize}

		\item Id
		\item StringExpr
		\item CastExpr
		\item ConstExpr
		\item PostExpr
		\item UnaryExpr
	\end{itemize}

	\item Declarator
	\begin{itemize}
		\item FunDeclarator
		\item ArrDeclarator
	\end{itemize}

	\item TypedefName
	\item TypeSpecifier
	\begin{itemize}
		\item VoidType
		\item RecordType
		\item IntType
		\item NameType
		\item CharType
	\end{itemize}

\end{itemize}

\acks

Many thanks to TAs
% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\section*{Reference}
Compilers: Principles, Techniques and Tools\\
Xiao Jia's and other TAs' materials\\

\end{document}
